<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Velocímetro por Sensores</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 10px;
        }
        
        h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .card {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        .speed-display {
            text-align: center;
            padding: 30px 20px;
        }
        
        .speed-value {
            font-size: 3.5rem;
            font-weight: bold;
            margin: 15px 0;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .unit {
            font-size: 1.2rem;
            opacity: 0.8;
        }
        
        .axis-display {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .axis {
            text-align: center;
            flex: 1;
        }
        
        .axis-value {
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .chart-container {
            height: 150px;
            margin-top: 15px;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        
        .settings {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        label {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        input[type="number"] {
            padding: 10px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1rem;
        }
        
        input[type="number"]:focus {
            outline: 2px solid rgba(255, 255, 255, 0.5);
        }
        
        .status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-weight: bold;
        }
        
        .moving {
            background: rgba(76, 175, 80, 0.3);
            color: #a5d6a7;
        }
        
        .stationary {
            background: rgba(244, 67, 54, 0.3);
            color: #ef9a9a;
        }
        
        .instructions {
            font-size: 0.9rem;
            text-align: center;
            opacity: 0.8;
            margin-top: 10px;
        }
        
        .permission-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }
        
        .permission-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        @media (max-width: 500px) {
            .speed-value {
                font-size: 2.8rem;
            }
            
            .axis-value {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Velocímetro por Sensores</h1>
            <p>Usa el acelerómetro y giroscopio para calcular velocidad</p>
        </header>
        
        <div class="card speed-display">
            <h2>Velocidad Actual</h2>
            <div class="speed-value">0.00 <span class="unit">m/s</span></div>
            
            <div class="axis-display">
                <div class="axis">
                    <div>X</div>
                    <div class="axis-value">0.00</div>
                </div>
                <div class="axis">
                    <div>Y</div>
                    <div class="axis-value">0.00</div>
                </div>
                <div class="axis">
                    <div>Z</div>
                    <div class="axis-value">0.00</div>
                </div>
            </div>
            
            <div class="chart-container">
                <canvas id="speedChart"></canvas>
            </div>
            
            <div id="movementStatus" class="status stationary">SIN MOVIMIENTO</div>
        </div>
        
        <div class="card settings">
            <h2>Ajustes</h2>
            
            <div class="setting-group">
                <label for="threshold">Umbral de quietud (m/s²):</label>
                <input type="number" id="threshold" value="0.2" step="0.05" min="0.05" max="1.0">
            </div>
            
            <div class="setting-group">
                <label for="quietTime">Tiempo para considerar quietud (ms):</label>
                <input type="number" id="quietTime" value="1000" step="100" min="500" max="5000">
            </div>
            
            <div class="setting-group">
                <label for="gravityCompensation">Compensación de gravedad:</label>
                <select id="gravityCompensation">
                    <option value="true">Activada</option>
                    <option value="false">Desactivada</option>
                </select>
            </div>
            
            <button id="resetBtn" class="permission-btn">Reiniciar Velocidad</button>
        </div>
        
        <div class="instructions">
            <p>Mueve tu teléfono para ver los cambios en la velocidad calculada.</p>
            <p>Los valores por debajo del umbral durante el tiempo establecido reinician la velocidad a cero.</p>
        </div>
    </div>

    <script>
        // Elementos de la interfaz
        const speedValueElement = document.querySelector('.speed-value');
        const axisXElement = document.querySelector('.axis:nth-child(1) .axis-value');
        const axisYElement = document.querySelector('.axis:nth-child(2) .axis-value');
        const axisZElement = document.querySelector('.axis:nth-child(3) .axis-value');
        const movementStatusElement = document.getElementById('movementStatus');
        const thresholdInput = document.getElementById('threshold');
        const quietTimeInput = document.getElementById('quietTime');
        const gravityCompensationSelect = document.getElementById('gravityCompensation');
        const resetBtn = document.getElementById('resetBtn');
        const speedChartCanvas = document.getElementById('speedChart');
        
        // Variables para el cálculo de velocidad
        let velocity = { x: 0, y: 0, z: 0 };
        let lastAcceleration = { x: 0, y: 0, z: 0 };
        let lastTime = 0;
        let gravity = { x: 0, y: 0, z: 9.81 }; // Gravedad por defecto
        let isStationary = false;
        let stationaryStartTime = 0;
        
        // Historial de velocidad para la gráfica (3 segundos)
        let speedHistory = [];
        const historyDuration = 3000; // 3 segundos en ms
        let chart = null;
        
        // Inicializar gráfica
        function initChart() {
            const ctx = speedChartCanvas.getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Velocidad (m/s)',
                        data: [],
                        borderColor: 'rgba(255, 255, 255, 0.8)',
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        borderWidth: 2,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            display: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        },
                        y: {
                            display: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            },
                            suggestedMin: 0,
                            suggestedMax: 5
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: 'rgba(255, 255, 255, 0.8)'
                            }
                        }
                    }
                }
            });
        }
        
        // Actualizar gráfica
        function updateChart() {
            if (!chart) return;
            
            const now = Date.now();
            const cutoffTime = now - historyDuration;
            
            // Filtrar datos antiguos
            speedHistory = speedHistory.filter(point => point.time > cutoffTime);
            
            // Actualizar datos de la gráfica
            chart.data.labels = speedHistory.map(point => 
                ((point.time - cutoffTime) / 1000).toFixed(1) + 's'
            );
            chart.data.datasets[0].data = speedHistory.map(point => point.speed);
            
            chart.update('none');
        }
        
        // Calcular la magnitud de un vector
        function magnitude(vector) {
            return Math.sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);
        }
        
        // Procesar datos del acelerómetro
        function handleMotionEvent(event) {
            const acceleration = event.accelerationIncludingGravity;
            const rotation = event.rotationRate;
            const currentTime = Date.now();
            
            if (!lastTime) {
                lastTime = currentTime;
                lastAcceleration = { 
                    x: acceleration.x || 0, 
                    y: acceleration.y || 0, 
                    z: acceleration.z || 0 
                };
                return;
            }
            
            // Calcular delta de tiempo en segundos
            const dt = (currentTime - lastTime) / 1000;
            
            // Compensar gravedad si está activado
            let linearAcceleration = { x: 0, y: 0, z: 0 };
            const useGravityCompensation = gravityCompensationSelect.value === 'true';
            
            if (useGravityCompensation) {
                linearAcceleration.x = (acceleration.x || 0) - gravity.x;
                linearAcceleration.y = (acceleration.y || 0) - gravity.y;
                linearAcceleration.z = (acceleration.z || 0) - gravity.z;
            } else {
                linearAcceleration.x = acceleration.x || 0;
                linearAcceleration.y = acceleration.y || 0;
                linearAcceleration.z = acceleration.z || 0;
            }
            
            // Integrar para obtener velocidad (método trapezoidal para mejor precisión)
            velocity.x += (lastAcceleration.x + linearAcceleration.x) * 0.5 * dt;
            velocity.y += (lastAcceleration.y + linearAcceleration.y) * 0.5 * dt;
            velocity.z += (lastAcceleration.z + linearAcceleration.z) * 0.5 * dt;
            
            // Actualizar aceleración anterior
            lastAcceleration = { ...linearAcceleration };
            lastTime = currentTime;
            
            // Obtener umbrales de los inputs
            const threshold = parseFloat(thresholdInput.value);
            const quietTime = parseInt(quietTimeInput.value);
            
            // Verificar si estamos en estado estacionario
            const accMagnitude = magnitude(linearAcceleration);
            
            if (accMagnitude < threshold) {
                if (!isStationary) {
                    stationaryStartTime = currentTime;
                    isStationary = true;
                } else if (currentTime - stationaryStartTime > quietTime) {
                    // Reiniciar velocidad si hemos estado quietos el tiempo suficiente
                    velocity = { x: 0, y: 0, z: 0 };
                }
            } else {
                isStationary = false;
            }
            
            // Calcular velocidad total
            const totalSpeed = magnitude(velocity);
            
            // Actualizar interfaz
            speedValueElement.textContent = totalSpeed.toFixed(2) + ' m/s';
            axisXElement.textContent = velocity.x.toFixed(2);
            axisYElement.textContent = velocity.y.toFixed(2);
            axisZElement.textContent = velocity.z.toFixed(2);
            
            // Actualizar estado de movimiento
            if (isStationary && (currentTime - stationaryStartTime > quietTime)) {
                movementStatusElement.textContent = 'SIN MOVIMIENTO';
                movementStatusElement.className = 'status stationary';
            } else {
                movementStatusElement.textContent = 'EN MOVIMIENTO';
                movementStatusElement.className = 'status moving';
            }
            
            // Actualizar historial de velocidad
            speedHistory.push({
                time: currentTime,
                speed: totalSpeed
            });
            
            // Actualizar gráfica
            updateChart();
        }
        
        // Calibrar gravedad
        function calibrateGravity() {
            if (window.DeviceMotionEvent) {
                // Tomar muestras durante 1 segundo para calcular la gravedad
                let samples = [];
                let sampleCount = 0;
                const maxSamples = 10;
                
                const sampleInterval = setInterval(() => {
                    window.addEventListener('devicemotion', function calibrateHandler(event) {
                        const acc = event.accelerationIncludingGravity;
                        if (acc) {
                            samples.push({
                                x: acc.x || 0,
                                y: acc.y || 0,
                                z: acc.z || 0
                            });
                            sampleCount++;
                            
                            if (sampleCount >= maxSamples) {
                                window.removeEventListener('devicemotion', calibrateHandler);
                                clearInterval(sampleInterval);
                                
                                // Calcular promedio
                                gravity = {
                                    x: samples.reduce((sum, sample) => sum + sample.x, 0) / samples.length,
                                    y: samples.reduce((sum, sample) => sum + sample.y, 0) / samples.length,
                                    z: samples.reduce((sum, sample) => sum + sample.z, 0) / samples.length
                                };
                                
                                alert('Gravedad calibrada correctamente');
                            }
                        }
                    }, { once: true });
                }, 100);
            }
        }
        
        // Reiniciar velocidad
        function resetVelocity() {
            velocity = { x: 0, y: 0, z: 0 };
            lastAcceleration = { x: 0, y: 0, z: 0 };
            lastTime = 0;
            speedHistory = [];
            updateChart();
        }
        
        // Solicitar permisos y inicializar
        function initApp() {
            // Inicializar gráfica
            initChart();
            
            // Configurar event listeners
            resetBtn.addEventListener('click', resetVelocity);
            
            // Solicitar permisos de sensores
            if (typeof DeviceMotionEvent !== 'undefined' && 
                typeof DeviceMotionEvent.requestPermission === 'function') {
                // iOS 13+ requiere solicitud de permiso
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('devicemotion', handleMotionEvent);
                            calibrateGravity();
                        } else {
                            alert('Se necesitan permisos de sensores para usar esta aplicación');
                        }
                    })
                    .catch(console.error);
            } else {
                // Navegadores que no requieren solicitud explícita
                window.addEventListener('devicemotion', handleMotionEvent);
                
                // Calibrar gravedad después de un breve retraso
                setTimeout(calibrateGravity, 1000);
            }
        }
        
        // Inicializar la aplicación cuando se carga la página
        window.addEventListener('load', initApp);
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</body>
</html>
